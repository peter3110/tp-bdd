\documentclass[11pt, a4paper]{article}
\usepackage[paper=a4paper, left=1.5cm, right=1.5cm, bottom=1.5cm, top=1.5cm]{geometry}
%
\usepackage[utf8]{inputenc}
\usepackage[spanish]{babel}
\usepackage{ulem}
\usepackage{listings}
\usepackage{xcolor}

\usepackage{caratula/caratula}
\def\doubleunderline#1{\underline{\underline{#1}}}

\colorlet{punct}{red!60!black}
\definecolor{background}{HTML}{EEEEEE}
\definecolor{delim}{RGB}{20,105,176}
\colorlet{numb}{magenta!60!black}
\lstdefinelanguage{json}{
    basicstyle=\normalfont\ttfamily,
    numbers=left,
    numberstyle=\scriptsize,
    stepnumber=1,
    numbersep=8pt,
    showstringspaces=false,
    breaklines=true,
    frame=lines,
    backgroundcolor=\color{background},
    literate=
     *{0}{{{\color{numb}0}}}{1}
      {1}{{{\color{numb}1}}}{1}
      {2}{{{\color{numb}2}}}{1}
      {3}{{{\color{numb}3}}}{1}
      {4}{{{\color{numb}4}}}{1}
      {5}{{{\color{numb}5}}}{1}
      {6}{{{\color{numb}6}}}{1}
      {7}{{{\color{numb}7}}}{1}
      {8}{{{\color{numb}8}}}{1}
      {9}{{{\color{numb}9}}}{1}
      {:}{{{\color{punct}{:}}}}{1}
      {,}{{{\color{punct}{,}}}}{1}
      {\{}{{{\color{delim}{\{}}}}{1}
      {\}}{{{\color{delim}{\}}}}}{1}
      {[}{{{\color{delim}{[}}}}{1}
      {]}{{{\color{delim}{]}}}}{1},
}

\begin{document}

\input{caratula.tex}
%Carátula
\maketitle
\newpage

%Indice
\tableofcontents
\newpage

% Demás secciones
%
\section{Introducción}

En el presente trabajo llevamos nuestro proyecto a MongoDB, analizaremos maneras de representarlo para distintas queries con sus ventajas y desventajas y escribiremos el c\'odigo de cada map-reduce.

\section{Documentos para Mongo}

A continuaci\'on vamos a definir el documento para Mongo en cada una de las queries dadas y argumentar la elecci\'on de dicho documento contando, a alto nivel, como ser\'ian los inserts, mantenimiento y busqueda con map-reduce.

%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Cr\'imenes cometidos por persona}
1. Para mayor nro. de crimenes cometidos por alguna persona \

2. Para nro de crimenes promedio cometidos por criminales \

Analizaremos la querie que nos pide el mayor n\'umero de crimines cometidos por alguna persona y n\'umero de cr\'imenes promedio cometidos. Elegimos diseñar el documento expuesto a continuación: 

\begin{lstlisting}[language=json]
	[
		{
			dniCulpable: 37206752,
			idCaso: 2
		}
	]
\end{lstlisting}

Guardaremos en cada documento el \textbf{dniCulpable} de la persona que fue encontrada culpable del crime \textbf{idCaso}. \

\subsubsection{Insert}

Cada vez que una persona es hallada culpable de un nuevo caso, creamos un nuevo documento con su dni y el caso en cuesti\'on. Esto es una operaci\'on muy r\'apida pues no depende de otros valores.

\subsubsection{Mantenimiento}

Las ventajas de esta manera de representar la informaci\'on est\'an en su mantenimiento. Cada documento ocupa poco espacio y, al no depender de nada m\'as, es facil de mantener y escalar. \

En un principio analizamos la posibilidad de tener un arreglo de casos por cada dni, pero esto requer\'ia mantener una estructura que no sabemos cuanto puede crecer en el tiempo y puede generar problemas al alcanzar el limite de disco. Por eso decidimos utilizar algo m\'as sencillo, pero que podamos garantizar facilmente su mantenimiento y escalabilidad.

\subsubsection{Map-Reduce}

El map devuelve para una única clave, todos los crímenes cometidos por cada dni. El recorre el array de tuplas, se arma un mapa que guarda para cada dni la cantidad de crímenes cometidos por este, y posteriormente recorre dicho mapa y devuelve el máximo valor en un caso, y el promedio en otro. En el ejemplo, ponemos el caso en que calcula el máximo.

\begin{lstlisting}
db.doc1.mapReduce(
    function() {
        emit(1, (this["dniCulpable"], 1) );
    },
    function(key,value) { 
        var mapa = {};
        for(i = 0; i < value.length; i++) {
            mapa[value[i][0]] = mapa[value[i][0]] + 1;
        }
        var res = 0;
        for(var elem in map) {
        	res = max(res, elem.value);
        }
        return res;
)
\end{lstlisting}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Ciudades con mayor n\'umero de cr\'imenes}

Analizaremos la querie que nos pide las 10 ciudades con mayor n\'umero de crímenes. Elegimos el documento expuesto a continuación:\

\begin{lstlisting}[language=json]
	[
		{
			idCiudad: 4,
			dniCulpable: 37206752
		}
	]
\end{lstlisting}

Guardaremos en cada documento,  una referencia a la ciudad en \textbf{idCiudad} y un culpable de alg\'un crimen como \textbf{dniCulpable}.

\subsubsection{Insert}

Cada vez que se reporte un nuevo crimen, creamos un documento nuevo con la informaci\'on.

\subsubsection{Mantenimiento}

Es similar a la anterior querie analizada.

\subsubsection{Map-Reduce}

El map nos debe calcular para ciudad, cuantos cr\'imenes tiene (idea similar a la queria anterior). El reduce, debe poder ordenarnos la ciudad seg\'un sus crimenes y quedarnos con las 10 mas grandes. Para hacer esto, creamos un heap de tamaño 10, y al recorrer el mapa, insertamos de forma ordenada cada valor.
\begin{lstlisting}
db.doc2.mapReduce(
    function() {
        emit(1, (this["idCiudad"], 1) );
    },
    function(key,value) { 
        var mapa = {};
        for(i = 0; i < value.length; i++) {
            mapa[value[i][0]] = mapa[value[i][0]] + 1;
        }
        var res = binaryHeap(10);
        for(var elem in map) {
        	res.insert(elem.value);
        }
        return res;
)
\end{lstlisting}
%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Personas como testigos en casos}

La querie consiste en responder cuántas personas se han visto involucradas como testigos en el mayor número de casos. Construimos el siguiente documento:

\begin{lstlisting}[language=json]
	[
		{
			dniTestigo: 27893435,
			idCasosInvolucradaComoTestigo:
				[
					{idCaso: 1},
					{idCaso: 4},
					{idCaso: 6}
				]
		}
	]
\end{lstlisting}

En \textbf{dniTestigo} representamos de que testigo se trata y luego tenemos un arreglo denominado \textbf{idCasosInvolucradaComoTestigo} en donde cada elemento es un caso en donde esa persona es testigo.\

Si bien podiamos optar por un dise\~no similar a los anteriores, decidimos probar con otro que tiene otras ventajas y desventajas que marcaremos.

\subsubsection{Insert}

El Insert es mas costoso que en los anteriores pues debemos buscar el documento que contenga el dni del testigo del nuevo caso. Notemos que en caso de no existir un documento debemos crear uno nuevo. Una vez que lo tenemos, debemos agregar un nuevo caso al arreglo.

\subsubsection{Mantenimiento}

Mencionamos este caso anteriormente. La desventaja que tiene es que va a ir creciendo de tama\~no cada documento y eventualmente puede llenar el disco. La soluci\'on que se nos ocurre es que, en caso de pasar eso, creamos un nuevo documento para ese testigo en donde a partir de ese momento iremos agregando los casos. En el map-reduce asumiremos que tenemos este dise\~no ya que es m\'as interesante.

\subsubsection{Map-Reduce}

El map debe decirnos, para un testigo, en cuantos casos estuvo. Esto es simplemente la suma del largo del arreglo \textbf{idCasosInvolucradaComoTestigo} en cada documento en el que aparezca el dni. El reduce debemos primero determinar cu\'al es que apareci\'o en m\'as casos y luego retornar todas las personas que hayan aparecido en exactamente esa cantidad de casos que calculamos.\\

Este Map-Reduce es m\'as eficiente que con el dise\~no usado anteriormente pues recorre muchisimos menos documentos. Recordemos que antes exist\'ia un documento por caso, y ac\'a cada documento va a seguir creciendo hasta que no quede m\'as lugar en el disco.
\begin{lstlisting}
db.doc3.mapReduce(
    function() {
        emit(this["dniTestigo"], this["idCasosInvolucradaComoTestigo"].length);
    },
    function(key,value) { 
        max = value[0];
        for(i = 1; i < value.length; i++) {
            if (max < value[i]) { 
                max = value[i];  
            }
        }
        var res = 0;
        for(i = 0; i < value.length; i++) {
        	if (value[i] == max) {
        		res = res + 1;
        	}
        }
        return res;
)
\end{lstlisting}
%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Casos con mayor n\'umero de involucrados o evidencias}

Para esas 2 queries utilizaremos un mismo dise\~no que es el siguiente:

\begin{lstlisting}[language=json]
   [
   		{
   			idCaso: 4,
	   		{
	   			idEvidencias: 
	   				[	
	   					{idEvidencia: 3},
	   					{idEvidencia: 4}
	   				],
	   			dniInvolucrados:
	   				[
	   					{dniInvolucrado: 37206752}
	   				]
	   		}
	   	}
   ]
\end{lstlisting}

En donde usaremos \textbf{idCaso} como clave, y para cada uno tendremos las distintas evidencias en \textbf{idEvidencias} y los involucrados en \textbf{dniInvolucrados}.

\subsubsection{Insert}

A lo largo del tiempo, ir\'an apareciendo evidencias nuevas y gente involucrada. Como en la anterior querie, debemos actualizar el documento agregando dicha informaci\'on seg\'un que caso se trate.

\subsubsection{Mantenimiento}

A diferencia del anterior, en este caso podemos pensar que es realmente muy dificil que llenemos un disco con este documento pues el orden de magnitud de las evidencias y los involucrados no parece ser tanto. En caso de llevar acabo un sistema as\'i, siempre se puede consultar un limite para poder tomar una decisi\'on de dise\~no de estas caracter\'isticas. Adem\'as de esta diferencia, en caso de llenarse el disco podemos utilizar una t\'ecnica similar a la ya expuesta en la queria anterior.

\subsubsection{Map-Reduce}

Dependiendo la querie, dado un caso deberemos contar evidencias o involucrados. \
En el próximo ejemplo, sólo vamos a contar evidencias. \
En el map, mapeamos a un mismo key tuplas con el idCaso y la cantidad de evidencias correspondientes a dicho caso. En el reduce, recorremos el arreglo de valores \textbf{value}, y vamos guardando en un mapa para cada idCaso, la cantidad de evidencias que le corresponden. En la variable $maximo$, vamos actualizando en cada paso la máxima cantidad de evidencias que tiene algún caso. Luego, recorremos el mapa y devolvemos todos los idCaso cuyo valor es igual a la variable $maximo$.
\begin{lstlisting}
db.doc4.mapReduce(
    function() {
        emit(1, (this["idCaso"], this["idEvidencias"].length) );
    },
    function(key,value) { 
        var maximo = 0;
        var mapa = {};
        for(i = 0; i < value.length; i++) {
            mapa[value[i][0]] = mapa[value[i][0]] + value[i][1];
            maximo = max(maximo, mapa[value[i][0]]);
        }
        var res = new Array();
        for(var elem in mapa) {
        	if (elem.value == maximo) {
        		res.push(elem.key);
        	}
        }
        return res;
)
\end{lstlisting}

%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Crimenes cometidos en los \'ultimos 45 d\'ias}

La \'ultima querie nos pide la cantidad de cr\'imenes de cada tipo cometidos en los ultimos 45 dias. Elegimos el siguiente dise\~no para el documento:

\begin{lstlisting}[language=json]
	[
		{
			idTipoCrimen: 4,
			cantCrimenesPorFecha:
				{
					'2014-10-08': 4,
					'2015-03-10': 1,
					'2016-10-10': 2
				}
		}
	]
\end{lstlisting}

En donde \textbf{idTipoCrimen} es la clave que representa un tipo de crimen, y el mapa \textbf{cantCrimenesPorFecha}, cuyas claves son fechas y los valores cantidad de cr\'imenes en cada una. Este documento tendr\'a la propiedad de que solo mantendremos fechas en los \'ultimos 45 d\'ias guardadas (En Mantenimiento desarrollaremos mejor este punto).

\subsubsection{Insert}
Buscamos el tipo de crimen correspondiente para tener el documento (o crear un nuevo si no existe). Luego, buscamos en el diccinario la clave correspondiente a la fecha, e incrementamos su valor. En caso de no existir dicha clave, la creamos con el valor 1.

\subsubsection{Mantenimiento}

Para optimizar el uso del disco, creamos un documento para cada tipo de crimen, y dicho documento tiene una cantidad de espacio acotado pues puede contener como mucho 45 fechas distintas. Esto es una ventaja a la hora de escalar esta estructura.\

Para poder garantizar la propiedad de que solo contenga crimenes de los \'ultimos 45 d\'ias, cuando cambia de d\'ia debemos realizar una tarea de mantenimiento. Hay que recorrer el diccionario correspondiente a cada tipo de crimen, y borrar las entradas correspondientes a fechas de hace más de 45 días. Este proceso puede ser r\'apido, pues no creemos que existan muchisimos tipos de cr\'imenes y como mencionamos, hay como mucho 45 fechas. Esto quiere decir que en este proceso eliminaremos como mucho 1 de ellas, ya que al cambia de d\'ia alguna puede haber pasado a ser 46 d\'ias antes.

\subsubsection{Map-Reduce}

En el map tendremos el tipo de crimen como la clave, y como valor emitiremos las cantidades de crímenes registradas en cada fecha. \
En el reduce calcularemos la suma de todos los crímenes en las fechas que hay guardadas (recordemos que todas están incluidas en los últimos 45 días). \
\begin{lstlisting}
db.doc5.mapReduce(
    function() {
    	for (i = 0; i < this["cantCrimenesPorFecha"].length; i++) {
    		for (var elem in this["cantCrimenesPorFecha"][i]) {
				emit(this["idTipoCrimen"], elem.value);
			}
    	}
    },
    function(key,value) {
    	var res = 0;
    	for (i = 0; i < value.length; i++) {
    		res = res + value[i];
    	}
    	return res;
    }
)
\end{lstlisting}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Implementaci\'on de Map-Reduce}

\section{Conclusiones}

\end{document}
